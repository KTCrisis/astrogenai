#!/usr/bin/env python3
"""
MCP YouTube Upload Server - AstroGenAI
Serveur MCP pour upload automatique sur YouTube
"""

import os
import sys
import datetime
import glob
from typing import Optional, List, Dict, Any
from pathlib import Path

# Import upload engine
from upload_engine import YouTubeUploader, UploadResult

try:
    from fastmcp import FastMCP
    FASTMCP_AVAILABLE = True
except ImportError:
    FASTMCP_AVAILABLE = False
    print("‚ö†Ô∏è FastMCP non disponible")

# Configuration
FINAL_MONTAGE_DIR = "../final_montage"
INDIVIDUAL_DIR = f"{FINAL_MONTAGE_DIR}/individual"

class YouTubeMCPServer:
    """Serveur MCP pour uploads YouTube AstroGenAI"""
    
    def __init__(self):
        self.uploader = YouTubeUploader()
        self.signs_order = [
            'aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo',
            'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'
        ]
        
        self.sign_names = {
            'aries': 'B√©lier', 'taurus': 'Taureau', 'gemini': 'G√©meaux',
            'cancer': 'Cancer', 'leo': 'Lion', 'virgo': 'Vierge',
            'libra': 'Balance', 'scorpio': 'Scorpion', 'sagittarius': 'Sagittaire',
            'capricorn': 'Capricorne', 'aquarius': 'Verseau', 'pisces': 'Poissons'
        }
    
    def find_latest_video(self, sign: str) -> Optional[str]:
        """Trouve la vid√©o la plus r√©cente pour un signe"""
        pattern = f"{INDIVIDUAL_DIR}/{sign}_final_*.mp4"
        videos = glob.glob(pattern)
        
        if not videos:
            return None
        
        # Retourner la plus r√©cente
        return max(videos, key=os.path.getctime)
    
    def find_complete_video(self) -> Optional[str]:
        """Trouve la vid√©o horoscope compl√®te la plus r√©cente"""
        pattern = f"{FINAL_MONTAGE_DIR}/horoscope_complet_*.mp4"
        videos = glob.glob(pattern)
        
        if not videos:
            return None
        
        return max(videos, key=os.path.getctime)
    
    def get_available_videos(self) -> Dict[str, Any]:
        """Liste toutes les vid√©os disponibles pour upload"""
        result = {
            "individual_videos": {},
            "complete_video": None,
            "total_available": 0
        }
        
        # Vid√©os individuelles
        for sign in self.signs_order:
            video_path = self.find_latest_video(sign)
            if video_path:
                result["individual_videos"][sign] = {
                    "path": video_path,
                    "filename": os.path.basename(video_path),
                    "size": os.path.getsize(video_path),
                    "modified": datetime.datetime.fromtimestamp(os.path.getmtime(video_path)).isoformat(),
                    "sign_name": self.sign_names.get(sign, sign.title())
                }
                result["total_available"] += 1
        
        # Vid√©o compl√®te
        complete_video = self.find_complete_video()
        if complete_video:
            result["complete_video"] = {
                "path": complete_video,
                "filename": os.path.basename(complete_video),
                "size": os.path.getsize(complete_video),
                "modified": datetime.datetime.fromtimestamp(os.path.getmtime(complete_video)).isoformat()
            }
        
        return result
    
    def upload_individual_video(self, sign: str, privacy: str = "private") -> Dict[str, Any]:
        """Upload vid√©o individuelle d'un signe"""
        try:
            # Validation du signe
            if sign not in self.signs_order:
                return {
                    "success": False,
                    "error": f"Signe invalide: {sign}. Disponibles: {', '.join(self.signs_order)}"
                }
            
            # Trouver la vid√©o
            video_path = self.find_latest_video(sign)
            if not video_path:
                return {
                    "success": False,
                    "error": f"Aucune vid√©o trouv√©e pour {sign}"
                }
            
            # Cr√©er m√©tadonn√©es avec privacy personnalis√©
            metadata = self.uploader.create_astro_metadata(sign)
            metadata.privacy_status = privacy
            
            # Upload
            result = self.uploader.upload_video(video_path, metadata)
            
            if result.success:
                return {
                    "success": True,
                    "video_id": result.video_id,
                    "video_url": result.video_url,
                    "title": result.title,
                    "sign": sign,
                    "sign_name": self.sign_names.get(sign, sign.title()),
                    "privacy": privacy,
                    "upload_time": result.upload_time,
                    "video_file": os.path.basename(video_path)
                }
            else:
                return {
                    "success": False,
                    "error": result.error,
                    "sign": sign
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": f"Erreur upload {sign}: {str(e)}"
            }
    
    def upload_batch_videos(self, signs: Optional[List[str]] = None, privacy: str = "private") -> Dict[str, Any]:
        """Upload en lot de plusieurs signes"""
        try:
            target_signs = signs if signs else self.signs_order
            results = []
            successful = 0
            failed = 0
            
            for sign in target_signs:
                print(f"üì§ Upload {sign}...")
                result = self.upload_individual_video(sign, privacy)
                
                if result["success"]:
                    successful += 1
                    print(f"‚úÖ {sign} upload√©: {result['video_url']}")
                else:
                    failed += 1
                    print(f"‚ùå {sign} √©chou√©: {result['error']}")
                
                results.append(result)
            
            return {
                "success": True,
                "results": results,
                "total": len(target_signs),
                "successful": successful,
                "failed": failed,
                "summary": f"{successful}/{len(target_signs)} uploads r√©ussis"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Erreur upload batch: {str(e)}"
            }
    
    def get_youtube_status(self) -> Dict[str, Any]:
        """Statut de la connexion YouTube"""
        try:
            channel_info = self.uploader.get_channel_info()
            available_videos = self.get_available_videos()
            
            return {
                "success": True,
                "youtube_connected": channel_info.get("success", False),
                "channel_info": channel_info,
                "available_videos_count": available_videos["total_available"],
                "complete_video_available": available_videos["complete_video"] is not None,
                "individual_videos_available": list(available_videos["individual_videos"].keys())
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Erreur statut YouTube: {str(e)}"
            }

# Initialisation serveur MCP
youtube_server = YouTubeMCPServer()

if FASTMCP_AVAILABLE:
    mcp = FastMCP("YouTubeUploadMCP")

    @mcp.tool()
    def get_youtube_status() -> dict:
        """
        V√©rifie l'√©tat de la connexion YouTube et des vid√©os disponibles.
        
        Returns:
            Statut de la connexion et inventaire des vid√©os
        """
        return youtube_server.get_youtube_status()

    @mcp.tool()
    def get_available_videos() -> dict:
        """
        Liste toutes les vid√©os disponibles pour upload.
        
        Returns:
            Inventaire d√©taill√© des vid√©os individuelles et compl√®tes
        """
        try:
            videos = youtube_server.get_available_videos()
            return {"success": True, "videos": videos}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    def upload_sign_video(sign: str, privacy: str = "private") -> dict:
        """
        Upload la vid√©o d'un signe sp√©cifique sur YouTube.
        
        Args:
            sign: Nom du signe (aries, taurus, etc.)
            privacy: Statut de confidentialit√© (private, unlisted, public)
        
        Returns:
            R√©sultat de l'upload avec URL YouTube
        """
        return youtube_server.upload_individual_video(sign, privacy)

    @mcp.tool()
    def upload_batch_signs(signs: Optional[List[str]] = None, privacy: str = "private") -> dict:
        """
        Upload en lot de plusieurs signes sur YouTube.
        
        Args:
            signs: Liste des signes √† uploader (par d√©faut: tous)
            privacy: Statut de confidentialit√© (private, unlisted, public)
        
        Returns:
            R√©sultats d√©taill√©s de tous les uploads
        """
        return youtube_server.upload_batch_videos(signs, privacy)

    @mcp.tool()
    def upload_complete_horoscope(privacy: str = "private") -> dict:
        """
        Upload la vid√©o horoscope compl√®te (12 signes) sur YouTube.
        
        Args:
            privacy: Statut de confidentialit√© (private, unlisted, public)
        
        Returns:
            R√©sultat de l'upload de la vid√©o compl√®te
        """
        try:
            complete_video = youtube_server.find_complete_video()
            if not complete_video:
                return {
                    "success": False,
                    "error": "Aucune vid√©o horoscope compl√®te trouv√©e"
                }
            
            # M√©tadonn√©es pour vid√©o compl√®te
            from upload_engine import VideoMetadata
            
            date = datetime.date.today().strftime("%d/%m/%Y")
            metadata = VideoMetadata(
                title=f"üîÆ Horoscope Complet du Jour - {date} | 12 Signes IA",
                description=f"""üåü Horoscope complet pour tous les signes du {date} !

ü§ñ G√©n√©r√© par Intelligence Artificielle astrologique
‚≠ê Pr√©dictions pour les 12 signes du zodiaque
üåô Influences cosmiques et conseils pratiques
üí´ Votre guide astral quotidien complet

üìÖ Dans cette vid√©o :
- Horoscope pour TOUS les signes
- Influences plan√©taires g√©n√©rales
- Conseils astrologiques du jour
- √ânergies cosmiques collectives

üîÆ AstroGenAI - Votre intelligence artificielle astrologique
Abonnez-vous pour vos pr√©dictions quotidiennes !

#Horoscope #Astrologie #TousLesSignes #Pr√©dictions #IA #AstroGenAI""",
                tags=["horoscope", "astrologie", "tous signes", "pr√©dictions", "IA", "complet", "quotidien"],
                privacy_status=privacy
            )
            
            result = youtube_server.uploader.upload_video(complete_video, metadata)
            
            if result.success:
                return {
                    "success": True,
                    "video_id": result.video_id,
                    "video_url": result.video_url,
                    "title": result.title,
                    "privacy": privacy,
                    "upload_time": result.upload_time,
                    "video_file": os.path.basename(complete_video),
                    "type": "complete_horoscope"
                }
            else:
                return {"success": False, "error": result.error}
                
        except Exception as e:
            return {"success": False, "error": str(e)}

    def test_mcp_tools():
        """Test des outils MCP - Version Corrig√©e"""
        print("üß™ Test des outils MCP YouTube")
        print("=" * 40)
        
        # Test 1: Statut YouTube (appel direct √† la classe)
        print("üîç Test 1: Statut YouTube")
        status = youtube_server.get_youtube_status()
        print(f"‚úÖ Connexion YouTube: {status.get('youtube_connected', False)}")
        if status.get('success'):
            channel_info = status.get('channel_info', {})
            print(f"üì∫ Cha√Æne: {channel_info.get('title', 'N/A')}")
            print(f"üë• Abonn√©s: {channel_info.get('subscribers', '0')}")
            print(f"üìä Vid√©os disponibles: {status.get('available_videos_count', 0)}")
        
        # Test 2: Vid√©os disponibles (appel direct √† la classe)
        print("\nüîç Test 2: Vid√©os disponibles")
        videos = youtube_server.get_available_videos()
        print(f"üìä {videos['total_available']} vid√©os individuelles trouv√©es")
        print(f"üé¨ Vid√©o compl√®te: {'Oui' if videos['complete_video'] else 'Non'}")
        
        # Afficher quelques signes disponibles
        available_signs = list(videos['individual_videos'].keys())
        if available_signs:
            print(f"‚≠ê Signes disponibles: {', '.join(available_signs[:5])}")
            if len(available_signs) > 5:
                print(f"   ... et {len(available_signs) - 5} autres")
        
        # Test 3: Test upload simul√© (juste validation)
        print("\nüîç Test 3: Validation upload")
        if available_signs:
            test_sign = available_signs[0]
            video_path = youtube_server.find_latest_video(test_sign)
            if video_path and os.path.exists(video_path):
                print(f"‚úÖ Vid√©o pr√™te pour upload: {test_sign}")
                print(f"üìÅ Fichier: {os.path.basename(video_path)}")
                print(f"üìè Taille: {os.path.getsize(video_path) / (1024*1024):.1f} MB")
            else:
                print(f"‚ùå Vid√©o introuvable pour {test_sign}")
        
        print("\n‚úÖ Tests MCP termin√©s")
        print("\nüí° Pour upload r√©el:")
        print(f"   result = youtube_server.upload_individual_video('{available_signs[0] if available_signs else 'aries'}', 'private')")

if __name__ == "__main__":
    print("üé¨ MCP YouTube Upload Server - AstroGenAI")
    print("=" * 50)
    
    if FASTMCP_AVAILABLE:
        print("üöÄ Serveur FastMCP pr√™t")
        
        # Test optionnel
        if "--test" in sys.argv:
            test_mcp_tools()
        elif "--server" in sys.argv:
            print("üöÄ D√©marrage serveur MCP...")
            mcp.run()
        elif "--upload" in sys.argv:
            # Test d'upload r√©el
            if len(sys.argv) > 2:
                sign = sys.argv[2]
                print(f"üì§ Test upload r√©el pour {sign}...")
                result = youtube_server.upload_individual_video(sign, "private")
                if result["success"]:
                    print(f"‚úÖ Upload r√©ussi: {result['video_url']}")
                else:
                    print(f"‚ùå Upload √©chou√©: {result['error']}")
            else:
                print("Usage: python youtube_upload_mcp.py --upload <sign>")
        else:
            print("üí° Options disponibles:")
            print("   python youtube_upload_mcp.py --test              # Test des outils")
            print("   python youtube_upload_mcp.py --server            # D√©marrer serveur")
            print("   python youtube_upload_mcp.py --upload aries      # Upload test")
            test_mcp_tools()
    else:
        print("‚ùå FastMCP non disponible")
        print("pip install fastmcp")