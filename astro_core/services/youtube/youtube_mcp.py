
#!/usr/bin/env python3
"""
MCP YouTube Server - AstroGenAI
Service MCP complet pour l'upload automatique sur YouTube.
"""

import os
import sys
import datetime
import glob
from typing import Optional, List, Dict, Any
from dataclasses import dataclass

# D√©pendances Google API
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from googleapiclient.errors import HttpError

# D√©pendance FastMCP
try:
    from fastmcp import FastMCP
    FASTMCP_AVAILABLE = True
except ImportError:
    FASTMCP_AVAILABLE = False
    print("‚ö†Ô∏è FastMCP non disponible")

# Configuration des chemins
FINAL_MONTAGE_DIR = os.environ.get("VIDEO_MONTAGE_DIR", "final_montage")
INDIVIDUAL_DIR = os.path.join(FINAL_MONTAGE_DIR, "individual")
CREDENTIALS_DIR = os.environ.get("YOUTUBE_CREDENTIALS_DIR", "youtube_mcp")

# =============================================================================
# PARTIE 1 : MOTEUR D'UPLOAD 
# =============================================================================

@dataclass
class VideoMetadata:
    """M√©tadonn√©es d'une vid√©o YouTube."""
    title: str
    description: str
    tags: list
    category_id: str = "22"  # People & Blogs par d√©faut
    privacy_status: str = "private"  # private, unlisted, public
    made_for_kids: bool = False

@dataclass
class UploadResult:
    """R√©sultat d'une tentative d'upload."""
    success: bool
    video_id: Optional[str] = None
    video_url: Optional[str] = None
    title: str = ""
    error: Optional[str] = None
    upload_time: Optional[str] = None

class YouTubeUploader:
    """Gestionnaire d'upload YouTube pour AstroGenAI."""

    def __init__(self, credentials_path: str = CREDENTIALS_DIR):
        self.credentials_file = os.path.join(credentials_path, 'credentials.json')
        self.token_file = os.path.join(credentials_path, 'token.json')
        self.youtube_service = None
        self._authenticate()

    def _authenticate(self):
        """Authentification √† l'API YouTube via le token."""
        try:
            if not os.path.exists(self.token_file):
                raise Exception(f"Token non trouv√© √† l'emplacement : {self.token_file}. Lancez d'abord le script d'authentification.")

            creds = Credentials.from_authorized_user_file(self.token_file)

            if not creds.valid:
                # Id√©alement, il faudrait g√©rer le refresh ici, mais pour l'instant on demande de relancer l'auth.
                raise Exception("Token expir√© ou invalide. Veuillez relancer l'authentification.")

            self.youtube_service = build('youtube', 'v3', credentials=creds)
            print("‚úÖ Auth YouTube OK")

        except Exception as e:
            print(f"‚ùå Erreur d'authentification YouTube : {e}")
            self.youtube_service = None # S'assurer que le service n'est pas utilisable
            raise

    def create_astro_metadata(self, sign: str, date: Optional[str] = None, is_complete_video: bool = False) -> VideoMetadata:
        """G√©n√®re des m√©tadonn√©es optimis√©es pour les vid√©os d'horoscope."""
        if not date:
            date_obj = datetime.date.today()
        else:
            date_obj = datetime.datetime.strptime(date, "%Y-%m-%d").date()

        formatted_date = date_obj.strftime("%d/%m/%Y")

# =============================================================================
# METADATA VIDEO LONGUE
# =============================================================================
        if is_complete_video:
            title = f"üîÆ Horoscope Complet du {formatted_date} - Tous les Signes Astrologiques | Pr√©dictions AI"
            description = f"""üåü D√©couvrez votre horoscope complet pour tous les signes du zodiaque pour le {formatted_date} !

Cette vid√©o, enti√®rement g√©n√©r√©e par une intelligence artificielle, vous offre un guide astral quotidien pour naviguer les √©nergies cosmiques.

‚ú® DANS CETTE VID√âO ‚ú®
- Pr√©dictions d√©taill√©es pour les 12 signes.
- Analyse des influences plan√©taires majeures du jour.
- Conseils pratiques et spirituels pour chaque signe.

üß† NOTRE TECHNOLOGIE üß†
- **Horoscopes** : G√©n√©r√©s par des mod√®les de langage avanc√©s (Ollama Llama3).
- **Calculs** : Positions plan√©taires r√©elles via Skyfield.
- **Visuels** : Constellations anim√©es cr√©√©es avec ComfyUI & AnimateDiff.
- **Voix & Sous-titres** : Synth√®se vocale (gTTS) et transcription (Whisper AI).

Abonnez-vous pour ne manquer aucune pr√©diction !

#Horoscope #Astrologie #AstroGenAI #IA #HoroscopeComplet #Zodiaque #Pr√©dictions #guidancespirituelle"""
            tags = ["horoscope", "astrologie", "horoscope complet", "tous les signes", "ia", "ai", "pr√©dictions", "zodiaque", "guidance"]
            category_id = "24" # Entertainment
        else:
# =============================================================================
# METADATA SHORT VIDEO
# =============================================================================
            sign_names = {
                'aries': 'B√©lier ‚ôà', 'taurus': 'Taureau ‚ôâ', 'gemini': 'G√©meaux ‚ôä',
                'cancer': 'Cancer ‚ôã', 'leo': 'Lion ‚ôå', 'virgo': 'Vierge ‚ôç',
                'libra': 'Balance ‚ôé', 'scorpio': 'Scorpion ‚ôè', 'sagittarius': 'Sagittaire ‚ôê',
                'capricorn': 'Capricorne ‚ôë', 'aquarius': 'Verseau ‚ôí', 'pisces': 'Poissons ‚ôì'
            }
            sign_name = sign_names.get(sign.lower(), sign.title())
            title = f"üîÆ Horoscope {sign_name} du {formatted_date} | Pr√©dictions IA Personnalis√©es"
            description = f"""üåü D√©couvrez votre horoscope personnalis√© pour le signe du {sign_name} en date du {formatted_date} !

Laissez notre intelligence artificielle astrologique vous guider √† travers les √©nergies cosmiques du jour.

#Horoscope #{sign.title()} #Astrologie #AstroGenAI #IA #Pr√©dictionsQuotidiennes #{sign_name.split()[0]}"""
            tags = ["horoscope", "astrologie", f"horoscope {sign.lower()}", sign.lower(), "ia", "pr√©dictions", "guidance", "zodiaque"]
            category_id = "22" # People & Blogs

        return VideoMetadata(title=title, description=description, tags=tags, category_id=category_id)

    def upload_video(self, video_path: str, metadata: VideoMetadata) -> UploadResult:
        """Upload une vid√©o sur YouTube avec les m√©tadonn√©es fournies."""
        if not self.youtube_service:
            return UploadResult(success=False, error="Service YouTube non authentifi√©.")
        if not os.path.exists(video_path):
            return UploadResult(success=False, error=f"Fichier vid√©o non trouv√© : {video_path}")

        try:
            print(f"üì§ D√©marrage de l'upload : {os.path.basename(video_path)}")
            print(f"üìù Titre : {metadata.title}")

            body = {
                'snippet': {
                    'title': metadata.title,
                    'description': metadata.description,
                    'tags': metadata.tags,
                    'categoryId': metadata.category_id
                },
                'status': {
                    'privacyStatus': metadata.privacy_status,
                    'madeForKids': metadata.made_for_kids
                }
            }

            media = MediaFileUpload(video_path, chunksize=-1, resumable=True)
            request = self.youtube_service.videos().insert(part=','.join(body.keys()), body=body, media_body=media)

            response = None
            while response is None:
                status, response = request.next_chunk()
                if status:
                    print(f"Progression de l'upload : {int(status.progress() * 100)}%")

            video_id = response['id']
            video_url = f"https://www.youtube.com/watch?v={video_id}"
            
            print(f"‚úÖ Upload r√©ussi ! ID de la vid√©o : {video_id}")
            print(f"üîó URL : {video_url}")

            return UploadResult(
                success=True,
                video_id=video_id,
                video_url=video_url,
                title=metadata.title,
                upload_time=datetime.datetime.now().isoformat()
            )

        except HttpError as e:
            error_msg = f"Erreur HTTP YouTube : {e.resp.status} {e.content.decode('utf-8')}"
            print(f"‚ùå {error_msg}")
            return UploadResult(success=False, title=metadata.title, error=error_msg)
        except Exception as e:
            error_msg = f"Erreur inattendue pendant l'upload : {e}"
            print(f"‚ùå {error_msg}")
            return UploadResult(success=False, title=metadata.title, error=error_msg)

    def get_channel_info(self) -> Dict[str, Any]:
        """R√©cup√®re les informations de la cha√Æne YouTube authentifi√©e."""
        if not self.youtube_service:
            return {'success': False, 'error': "Service YouTube non authentifi√©."}
        try:
            request = self.youtube_service.channels().list(part='snippet,statistics', mine=True)
            response = request.execute()
            
            if response.get('items'):
                channel = response['items'][0]
                return {
                    'success': True,
                    'channel_id': channel['id'],
                    'title': channel['snippet']['title'],
                    'subscribers': channel['statistics'].get('subscriberCount', '0'),
                    'videos': channel['statistics'].get('videoCount', '0'),
                    'views': channel['statistics'].get('viewCount', '0')
                }
            return {'success': False, 'error': 'Aucune cha√Æne trouv√©e pour ce compte.'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

# =============================================================================
# PARTIE 2 : SERVEUR MCP
# =============================================================================

class YouTubeMCPServer:
    """Serveur MCP qui utilise le YouTubeUploader pour exposer des outils."""

    def __init__(self):
        try:
            self.uploader = YouTubeUploader()
        except Exception as e:
            print("Impossible d'initialiser le YouTubeMCPServer car l'uploader a √©chou√©.")
            self.uploader = None
        
        self.signs_order = [
            'aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo',
            'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'
        ]
        self.sign_names = {sign: self.uploader.create_astro_metadata(sign).title.split(' ')[1] for sign in self.signs_order} if self.uploader else {}

    def _check_uploader(self):
        """V√©rifie si l'uploader est disponible."""
        if not self.uploader:
            raise Exception("Le moteur d'upload YouTube n'a pas pu √™tre initialis√©.")

    def find_latest_video(self, directory: str, pattern: str) -> Optional[str]:
        """Trouve le fichier le plus r√©cent correspondant √† un pattern."""
        path_pattern = os.path.join(directory, pattern)
        files = glob.glob(path_pattern)
        return max(files, key=os.path.getctime) if files else None

    def get_available_videos(self) -> Dict[str, Any]:
        """Liste toutes les vid√©os pr√™tes √† √™tre upload√©es."""
        self._check_uploader()
        result = {"individual_videos": {}, "complete_video": None, "total_available": 0}

        for sign in self.signs_order:
            video_path = self.find_latest_video(INDIVIDUAL_DIR, f"{sign}_final_*.mp4")
            if video_path:
                result["individual_videos"][sign] = {
                    "path": video_path,
                    "filename": os.path.basename(video_path),
                    "size_mb": round(os.path.getsize(video_path) / (1024*1024), 2)
                }
                result["total_available"] += 1
        
        complete_video = self.find_latest_video(FINAL_MONTAGE_DIR, "horoscope_complet_*.mp4")
        if complete_video:
            result["complete_video"] = {
                "path": complete_video,
                "filename": os.path.basename(complete_video),
                "size_mb": round(os.path.getsize(complete_video) / (1024*1024), 2)
            }
        
        return result

    def upload_individual_video(self, sign: str, privacy: str = "private") -> Dict[str, Any]:
        """Pr√©pare et upload la vid√©o pour un signe."""
        self._check_uploader()
        video_path = self.find_latest_video(INDIVIDUAL_DIR, f"{sign}_final_*.mp4")
        if not video_path:
            return {"success": False, "error": f"Aucune vid√©o finale trouv√©e pour {sign}."}

        metadata = self.uploader.create_astro_metadata(sign)
        metadata.privacy_status = privacy
        
        result = self.uploader.upload_video(video_path, metadata)
        return {"sign": sign, **result.__dict__}

    def upload_complete_horoscope(self, privacy: str = "private") -> Dict[str, Any]:
        """Pr√©pare et upload la vid√©o compl√®te."""
        self._check_uploader()
        video_path = self.find_latest_video(FINAL_MONTAGE_DIR, "horoscope_complet_*.mp4")
        if not video_path:
            return {"success": False, "error": "Aucune vid√©o compl√®te trouv√©e."}

        metadata = self.uploader.create_astro_metadata("", is_complete_video=True)
        metadata.privacy_status = privacy
        
        result = self.uploader.upload_video(video_path, metadata)
        return {"type": "complete_horoscope", **result.__dict__}

    def get_youtube_status(self) -> Dict[str, Any]:
        """Retourne l'√©tat de la connexion YouTube et des vid√©os."""
        self._check_uploader()
        channel_info = self.uploader.get_channel_info()
        available_videos = self.get_available_videos()
        return {
            "success": channel_info['success'],
            "youtube_connected": channel_info['success'],
            "channel_info": channel_info,
            "available_videos": available_videos
        }

# =============================================================================
# INITIALISATION ET OUTILS MCP
# =============================================================================

# Instance globale du service
youtube_server = YouTubeMCPServer()

if FASTMCP_AVAILABLE and youtube_server.uploader:
    mcp = FastMCP("YouTubeServiceMCP")

    @mcp.tool()
    def get_status() -> dict:
        """V√©rifie la connexion YouTube et liste les vid√©os pr√™tes."""
        return youtube_server.get_youtube_status()

    @mcp.tool()
    def upload_sign_video(sign: str, privacy: str = "private") -> dict:
        """Upload la vid√©o d'un signe. privacy: private, unlisted, ou public."""
        if sign not in youtube_server.signs_order:
            return {"success": False, "error": f"Signe invalide. Disponibles: {', '.join(youtube_server.signs_order)}"}
        return youtube_server.upload_individual_video(sign, privacy)
    
    @mcp.tool()
    def upload_complete_video(privacy: str = "private") -> dict:
        """Upload la vid√©o compl√®te. privacy: private, unlisted, ou public."""
        return youtube_server.upload_complete_horoscope(privacy)

    @mcp.tool()
    def upload_batch_videos(signs: Optional[List[str]] = None, privacy: str = "private") -> dict:
        """Upload en lot plusieurs vid√©os. Si 'signs' est omis, tous les signes sont upload√©s."""
        target_signs = signs if signs else youtube_server.signs_order
        results = [youtube_server.upload_individual_video(sign, privacy) for sign in target_signs]
        successful = sum(1 for r in results if r["success"])
        return {
            "summary": f"{successful}/{len(target_signs)} uploads r√©ussis.",
            "total_requested": len(target_signs),
            "successful_uploads": successful,
            "failed_uploads": len(target_signs) - successful,
            "details": results
        }

# Point d'entr√©e pour tests en ligne de commande
if __name__ == "__main__":
    print("üé¨ Service YouTube MCP - AstroGenAI")
    print("=" * 50)

    if not youtube_server.uploader:
        print("‚ùå Le service n'a pas pu d√©marrer. V√©rifiez les erreurs d'authentification ci-dessus.")
        sys.exit(1)
        
    if not FASTMCP_AVAILABLE:
        print("‚ùå FastMCP non disponible. Le serveur ne peut pas d√©marrer. `pip install fastmcp`")
        print("‚ÑπÔ∏è Vous pouvez toujours utiliser les classes en mode module.")
    else:
        # Ex√©cuter un test rapide si demand√©
        if "--test" in sys.argv:
            print("\nüß™ Lancement des tests...")
            status = youtube_server.get_youtube_status()
            if status['success']:
                print(f"‚úÖ Connexion r√©ussie √† la cha√Æne : {status['channel_info']['title']}")
                print(f"üìä Vid√©os individuelles pr√™tes : {status['available_videos']['total_available']}")
                if status['available_videos']['complete_video']:
                    print("üé¨ Vid√©o compl√®te pr√™te.")
                else:
                    print("‚ùì Pas de vid√©o compl√®te trouv√©e.")
            else:
                print(f"‚ùå Test de statut √©chou√© : {status.get('error')}")
        else:
            print("üöÄ D√©marrage du serveur FastMCP...")
            mcp.run()